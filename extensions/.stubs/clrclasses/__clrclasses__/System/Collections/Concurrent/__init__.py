from __clrclasses__.System import IDisposable as _n_0_t_0
from __clrclasses__.System import Array as _n_0_t_1
from __clrclasses__.System import TimeSpan as _n_0_t_2
from __clrclasses__.System import Func as _n_0_t_3
from __clrclasses__.System import Enum as _n_0_t_4
from __clrclasses__.System import IComparable as _n_0_t_5
from __clrclasses__.System import IFormattable as _n_0_t_6
from __clrclasses__.System import IConvertible as _n_0_t_7
from __clrclasses__.System.Collections import ICollection as _n_1_t_0
from __clrclasses__.System.Collections import IDictionary as _n_1_t_1
from __clrclasses__.System.Collections.Generic import IEnumerable as _n_2_t_0
from __clrclasses__.System.Collections.Generic import IReadOnlyCollection as _n_2_t_1
from __clrclasses__.System.Collections.Generic import IDictionary as _n_2_t_2
from __clrclasses__.System.Collections.Generic import IReadOnlyDictionary as _n_2_t_3
from __clrclasses__.System.Collections.Generic import IEqualityComparer as _n_2_t_4
from __clrclasses__.System.Collections.Generic import KeyValuePair as _n_2_t_5
from __clrclasses__.System.Collections.Generic import IEnumerator as _n_2_t_6
from __clrclasses__.System.Collections.Generic import IList as _n_2_t_7
from __clrclasses__.System.Linq import ParallelQuery as _n_3_t_0
from __clrclasses__.System.Threading import CancellationToken as _n_4_t_0
import typing
T = typing.TypeVar('T')
TKey = typing.TypeVar('TKey')
TValue = typing.TypeVar('TValue')
TSource = typing.TypeVar('TSource')
class BlockingCollection(_n_2_t_0[T], _n_1_t_0, _n_0_t_0, _n_2_t_1[T], typing.Generic[T]):
    @property
    def BoundedCapacity(self) -> int:"""BoundedCapacity { get; } -> int"""
    @property
    def IsAddingCompleted(self) -> bool:"""IsAddingCompleted { get; } -> bool"""
    @property
    def IsCompleted(self) -> bool:"""IsCompleted { get; } -> bool"""
    def __init__(self, collection: IProducerConsumerCollection[T]) -> BlockingCollection:...
    def __init__(self, collection: IProducerConsumerCollection[T], boundedCapacity: int) -> BlockingCollection:...
    def __init__(self, boundedCapacity: int) -> BlockingCollection:...
    def __init__(self) -> BlockingCollection:...
    def Add(self, item: T, cancellationToken: _n_4_t_0):...
    def Add(self, item: T):...
    @staticmethod
    def AddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T, cancellationToken: _n_4_t_0) -> int:...
    @staticmethod
    def AddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T) -> int:...
    def CompleteAdding(self):...
    def GetConsumingEnumerable(self, cancellationToken: _n_4_t_0) -> _n_2_t_0[T]:...
    def GetConsumingEnumerable(self) -> _n_2_t_0[T]:...
    def Take(self, cancellationToken: _n_4_t_0) -> T:...
    def Take(self) -> T:...
    @staticmethod
    def TakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object, cancellationToken: _n_4_t_0) -> int:...
    @staticmethod
    def TakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object) -> int:...
    def ToArray(self) -> _n_0_t_1[T]:...
    def TryAdd(self, item: T, millisecondsTimeout: int, cancellationToken: _n_4_t_0) -> bool:...
    def TryAdd(self, item: T, millisecondsTimeout: int) -> bool:...
    def TryAdd(self, item: T, timeout: _n_0_t_2) -> bool:...
    def TryAdd(self, item: T) -> bool:...
    @staticmethod
    def TryAddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T, millisecondsTimeout: int, cancellationToken: _n_4_t_0) -> int:...
    @staticmethod
    def TryAddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T, millisecondsTimeout: int) -> int:...
    @staticmethod
    def TryAddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T, timeout: _n_0_t_2) -> int:...
    @staticmethod
    def TryAddToAny(collections: _n_0_t_1[BlockingCollection[T]], item: T) -> int:...
    def TryTake(self, item: object, millisecondsTimeout: int, cancellationToken: _n_4_t_0) -> bool:...
    def TryTake(self, item: object, millisecondsTimeout: int) -> bool:...
    def TryTake(self, item: object, timeout: _n_0_t_2) -> bool:...
    def TryTake(self, item: object) -> bool:...
    @staticmethod
    def TryTakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object, millisecondsTimeout: int, cancellationToken: _n_4_t_0) -> int:...
    @staticmethod
    def TryTakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object, millisecondsTimeout: int) -> int:...
    @staticmethod
    def TryTakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object, timeout: _n_0_t_2) -> int:...
    @staticmethod
    def TryTakeFromAny(collections: _n_0_t_1[BlockingCollection[T]], item: object) -> int:...
class ConcurrentBag(IProducerConsumerCollection[T], _n_2_t_1[T], typing.Generic[T]):
    @property
    def IsEmpty(self) -> bool:"""IsEmpty { get; } -> bool"""
    def __init__(self, collection: _n_2_t_0[T]) -> ConcurrentBag:...
    def __init__(self) -> ConcurrentBag:...
    def Add(self, item: T):...
    def TryPeek(self, result: object) -> bool:...
class ConcurrentDictionary(_n_2_t_2[TKey, TValue], _n_1_t_1, _n_2_t_3[TKey, TValue], typing.Generic[TKey, TValue], typing.Iterable[TValue]):
    @property
    def IsEmpty(self) -> bool:"""IsEmpty { get; } -> bool"""
    def __init__(self, concurrencyLevel: int, capacity: int, comparer: _n_2_t_4[TKey]) -> ConcurrentDictionary:...
    def __init__(self, concurrencyLevel: int, collection: _n_2_t_0[_n_2_t_5[TKey, TValue]], comparer: _n_2_t_4[TKey]) -> ConcurrentDictionary:...
    def __init__(self, collection: _n_2_t_0[_n_2_t_5[TKey, TValue]], comparer: _n_2_t_4[TKey]) -> ConcurrentDictionary:...
    def __init__(self, comparer: _n_2_t_4[TKey]) -> ConcurrentDictionary:...
    def __init__(self, collection: _n_2_t_0[_n_2_t_5[TKey, TValue]]) -> ConcurrentDictionary:...
    def __init__(self) -> ConcurrentDictionary:...
    def __init__(self, concurrencyLevel: int, capacity: int) -> ConcurrentDictionary:...
    def AddOrUpdate(self, key: TKey, addValue: TValue, updateValueFactory: _n_0_t_3[TKey, TValue, TValue]) -> TValue:...
    def AddOrUpdate(self, key: TKey, addValueFactory: _n_0_t_3[TKey, TValue], updateValueFactory: _n_0_t_3[TKey, TValue, TValue]) -> TValue:...
    def AddOrUpdate(self, key: TKey, addValueFactory: _n_0_t_3[TKey, typing.Any, TValue], updateValueFactory: _n_0_t_3[TKey, TValue, typing.Any, TValue], factoryArgument: typing.Any) -> TValue:...
    def GetOrAdd(self, key: TKey, valueFactory: _n_0_t_3[TKey, typing.Any, TValue], factoryArgument: typing.Any) -> TValue:...
    def GetOrAdd(self, key: TKey, value: TValue) -> TValue:...
    def GetOrAdd(self, key: TKey, valueFactory: _n_0_t_3[TKey, TValue]) -> TValue:...
    def ToArray(self) -> _n_0_t_1[_n_2_t_5[TKey, TValue]]:...
    def TryAdd(self, key: TKey, value: TValue) -> bool:...
    def TryRemove(self, key: TKey, value: object) -> bool:...
    def TryUpdate(self, key: TKey, newValue: TValue, comparisonValue: TValue) -> bool:...
class ConcurrentQueue(IProducerConsumerCollection[T], _n_2_t_1[T], typing.Generic[T]):
    @property
    def IsEmpty(self) -> bool:"""IsEmpty { get; } -> bool"""
    def __init__(self, collection: _n_2_t_0[T]) -> ConcurrentQueue:...
    def __init__(self) -> ConcurrentQueue:...
    def Enqueue(self, item: T):...
    def TryDequeue(self, result: object) -> bool:...
    def TryPeek(self, result: object) -> bool:...
class ConcurrentStack(IProducerConsumerCollection[T], _n_2_t_1[T], typing.Generic[T]):
    @property
    def IsEmpty(self) -> bool:"""IsEmpty { get; } -> bool"""
    def __init__(self, collection: _n_2_t_0[T]) -> ConcurrentStack:...
    def __init__(self) -> ConcurrentStack:...
    def Clear(self):...
    def Push(self, item: T):...
    def PushRange(self, items: _n_0_t_1[T], startIndex: int, count: int):...
    def PushRange(self, items: _n_0_t_1[T]):...
    def TryPeek(self, result: object) -> bool:...
    def TryPop(self, result: object) -> bool:...
    def TryPopRange(self, items: _n_0_t_1[T], startIndex: int, count: int) -> int:...
    def TryPopRange(self, items: _n_0_t_1[T]) -> int:...
class EnumerablePartitionerOptions(_n_0_t_4, _n_0_t_5, _n_0_t_6, _n_0_t_7):
    NoBuffering: int
    _None: int
    value__: int
class IProducerConsumerCollection(_n_2_t_0[T], _n_1_t_0, typing.Generic[T]):
    def ToArray(self) -> _n_0_t_1[T]:...
    def TryAdd(self, item: T) -> bool:...
    def TryTake(self, item: object) -> bool:...
class OrderablePartitioner(Partitioner[TSource], typing.Generic[TSource]):
    @property
    def KeysNormalized(self) -> bool:"""KeysNormalized { get; set; } -> bool"""
    @property
    def KeysOrderedAcrossPartitions(self) -> bool:"""KeysOrderedAcrossPartitions { get; set; } -> bool"""
    @property
    def KeysOrderedInEachPartition(self) -> bool:"""KeysOrderedInEachPartition { get; set; } -> bool"""
    def GetOrderableDynamicPartitions(self) -> _n_2_t_0[_n_2_t_5[int, TSource]]:...
    def GetOrderablePartitions(self, partitionCount: int) -> _n_2_t_7[_n_2_t_6[_n_2_t_5[int, TSource]]]:...
class Partitioner(typing.Generic[TSource]):
    @property
    def SupportsDynamicPartitions(self) -> bool:"""SupportsDynamicPartitions { get; } -> bool"""
    def GetDynamicPartitions(self) -> _n_2_t_0[TSource]:...
    def GetPartitions(self, partitionCount: int) -> _n_2_t_7[_n_2_t_6[TSource]]:...
    def AsParallel(self) -> _n_3_t_0[TSource]:
        """Extension from: System.Linq.ParallelEnumerable"""
